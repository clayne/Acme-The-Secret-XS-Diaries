# PODNAME: Acme::The::Secret::XS::Diaries
# ABSTRACT: XS experiments of an XS n00b

=head1 Diary of learning XS

=head2 Day 1 - hello world

=head3 About

I read the first chapters of C<perlxstut>, minimalized the
instructions a bit and adapted it to L<Dist::Zilla|Dist::Zilla>.

=head3 Create a project

 $ dzil new Acme::The::Secret::XS::Diaries
 $ cd Acme-The-Secret-XS-Diaries
 $ git init
 $ git add lib/Acme/The/Secret/XS/Diaries.pm
 $ git add dist.ini
 $ git add Changes
 $ git add .gitignore
 $ git commit -m"initial project"

=head3 Create an XS file

Put a file into your project's top dir and name it after the last name
of your package, here C<Diaries.xs>:

 #include "EXTERN.h"
 #include "perl.h"
 #include "XSUB.h"
 
 #include "ppport.h"
 
 MODULE = Acme::The::Secret::XS::Diaries       PACKAGE = Acme::The::Secret::XS::Diaries
 
 void
 hello()
         CODE:
                 printf("Hello, world!\n");

=head3 Create a ppport.h file

The include file C<ppport.h> is something magic that you need to
create with this command inside your project's top dir:

 $ perl -MDevel::PPPort -eDevel::PPPort::WriteFile

=head3 Add XSLoader to your Perl module

Open your project's Perl module C<lib/Acme/The/Secret/XS/Diaries.pm>
and add the two XSLoader lines to it so the file looks like this:

 use strict;
 use warnings;
 
 package Acme::The::Secret::XS::Diaries;
 # ABSTRACT: Experiments of an XS n00b
 
 require XSLoader;
 XSLoader::load();
 
 1;

=head3 Create a test file

We run our module in a test file C<t/diaries.t> like this:

 #! /usr/bin/perl
 use Acme::The::Secret::XS::Diaries;
 use Test::More;
 
 Acme::The::Secret::XS::Diaries::hello();
 
 ok(1);
 done_testing;
 
=head3 Test it

With XS you must compile your distribution first before you can use
it. We do the whole build+test this way:

 $ dzil test --verbose

You get an output like this:

 [---snip---]
 t/diaries.t ............... 
 ok 1
 1..1
 Hello, world!
 ok
 [---snap---]

=head3 Done

That's it for day 1.

=head2 Day 2 - Passing single arguments

=head3 Export functions

Not XS related but we better export symbols using
L<Sub::Exporter|Sub::Exporter> before we continue.
This allows great flexibility on what of and how
exactly to import our module later.

=head3 integer arguments

We add an C<is_even> function to XS file:

 int
 is_even(input)
         int input
         CODE:
                 RETVAL = (input % 2 == 0);
         OUTPUT:
                 RETVAL

and use it from Perl in the test script like this:

 is(is_even(0), 1, "0 -> even");
 is(is_even(1), 0, "1 -> uneven");
 is(is_even(2), 1, "2 -> even");

What changed?

=over 4

=item We just added an argument C<input>

...which is of type C<int>, declared in kind-of K&R style (i.e., just
name the argument it in function signature and define its type later)
and used it as usual in C.

=item We assign result to a variable C<RETVAL>

...which comes along already pre-declared with the return type of the
function (if that is not C<void>).

=item We declared an C<OUTPUT:> block

...which names the variable that contains our return value, here
C<RETVAL>.

=back

=head3 string arguments

We add a C<hello_to> function to XS file:

 void
 hello_to(someone)
         const char * someone
         CODE:
                 printf("Hello, %s!\n", someone);

and use it from Perl in the test script like this:

 hello_to("birne");

Magically this works out of the box. There is a data conversion
happening from Perl string to C<const char *> which is defined in a
I<typemap>.

=head3 Interlude: typemaps

Normally the mapping between Perl and C data structures is declared in
a so called I<typemap>. We could define that by ourself in a file
C<typemap> but we go with the default typemaps for a while, as there
is a collection of default mappings coming with Perl's ExtUtils. If
you are curious you can find them this way:

 cat $(perldoc -l ExtUtils::testlib | sed -e 's/testlib.pm/typemap/')

=over 4

=item In the first part it maps C types to names (which try to match
their Perl corresponding data structure names if possible).

=item The second part (after the C<INPUT> line) declares how to map
them from Perl to C (for input parameters).

=item The third part (after the C<OUTPUT> line) declares how to map
them from C to Perl (for return values).

=back

We return to typemaps when we really need one.

=head3 array ref argument

Let's exercise how to pass an arrayref and loop over its values. Here
the parameter is still a single one: the array ref; a non-ref array
would need to read from argument stack, which we will try later.

We add this code:

 void
 hello_to_persons_arrayref(persons)
         AV *persons;
         PREINIT:
                 I32    i;
                 I32    len;
                 SV**   element;
                 STRLEN str_len;
                 char * el_str;
                 I32    el_int;
         PPCODE:
                 len = av_len(persons);
                 printf("Hello, %d persons:\n", len+1);
                 for (i = 0; i <= len; i++) {
                     element = av_fetch(persons, i, 0);
                     if (element != NULL) {
                        if (SvPOK(*element)) {
                           el_str = SvPV(*element, str_len);
                           printf("  %d: Hello, %s!\n", i, el_str);
                        } else if (SvIOK(*element)) {
                           el_int = SvIV(*element);
                           printf("  %d: Hello, %d!\n", i, el_int);
                        } else {
                          printf("  %d: (ignored)\n", i);
                        }
                     }
                 }

What happens here? Essentially it does what in Perl would be:

 sub hello_to_persons_arrayref {
         my ($persons) = @_;
         printf("Hello, %d persons:\n", scalar @$persons);
         for (my $i = 0; $i < @$persons; $i++) {
                 printf("  %d: Hello, %s!\n", $i, $persons->[$i]);
         }
 }

=over 4

=item * Our argument is an C<AV>, an array value.

=item * Directly after that we declare all other non-argument variables
in a C<PREINIT>. The early declaration conforms to C89, the PREINIT
ensures it creates correct C code even in certain situations with
additionally generated typemap code.

=item * The most interesting variable is C<element> of type
C<SV**>. An C<SV> is a scalar, which is what an array (C<AV>) can
contain; the many C<*> arise from the type of the function
(C<av_fetch>) from which we get it returned.

=item * Now we iterate by using the index to access the elements
inside the array ref.

We get the last index with C<av_len>, do a for loop over that, and get
each element with C<av_fetch>. (Confusingly the function C<av_len>,
despite its name, does not return the length but the highest element
index.)

Now, each element contains a scalar (C<SV>) but it can be anything, so
we check for each type respectively: C<SvPOK> return true if the SV
contains a string, C<SvIOK> returns true if the SV contains an
integer, etc.

We then handle each type respectively. We convert it to the type with
C<SvPV> (scalar to string) or C<SvIV> (scalar to int) and use the
converted value with the corresponding printf format.

=back

=head3 hash ref argument

Let's do a similar thing with a hashref:

 void
 hello_to_persons_hashref(persons)
         HV *persons;
         PREINIT:
                 SV*    value;
                 char*  key;
                 I32    keylen;
                 STRLEN str_len;
                 char * el_str;
                 I32    el_int;
         PPCODE:
                 hv_iterinit(persons);
                 printf("Hello, unknown amount of persons:\n");
                 while (value = hv_iternextsv(persons, &key, &keylen)) {
                       if (SvPOK(value)) {
                          el_str = SvPV(value, str_len);
                          printf("  Hello, %s %s!\n", el_str, key);
                       } else if (SvIOK(value)) {
                          el_int = SvIV(value);
                          printf("  Hello, %d %s!\n", el_int, key);
                       } else {
                          printf("  (ignored) %s\n", key);
                       }
                 }

=over 4

=item * Our argument is an C<HV>, a hash value.

=item * We initialize an iterator with C<hv_iterinit>. (It's not
really clear why we don't get an actual iterator handle to use the
iterator but refer to the HV itself.)

=item * Note that here we don't know in advance how many person
elements we get. This will work again in a later example when we
iterate over a known array of keys.

=item * We loop with C<while> as long as the next iterator access
returns something.

=item * For iterator access we use a convenience function
C<hv_iternextsv> which gives us all info in one step: the actual value
and the key with its length.

=item * With the value SV it's now similar to our array loop above.

The scalar can be anything, so we check for each type respectively
with C<SvPOK>, C<SvIOK>, etc., and convert according to the recognized
type with C<SvPV> or C<SvIV>. With that we use a fitting printf
format.

=back

=head3 hash ref argument, accessed by keys

To see how to access a hash via keys we combine the last two lessons;
we loop over the array of keys and fetch hash elements by them:

 void
 hello_to_persons_hashref_by_keys(persons, keys)
         HV *persons;
         AV *keys;
         PREINIT:
                 I32    i;
                 I32    len;
                 SV**   key_el;
                 SV**   value;
                 char*  key;
                 STRLEN str_len;
                 char * el_str;
                 I32    el_int;
         PPCODE:
                 len = av_len(keys);
                 printf("Hello, %d persons:\n", len+1);
                 for (i = 0; i <= len; i++) {
                     key_el = av_fetch(keys, i, 0);
                     if (key_el != NULL && SvPOK(*key_el)) {
                           key = SvPV(*key_el, str_len);
                           value = hv_fetch(persons, key, strlen(key), 0);
                           if (SvPOK(*value)) {
                              el_str = SvPV(*value, str_len);
                              printf("  Hello, %s %s!\n", el_str, key);
                           } else if (SvIOK(*value)) {
                              el_int = SvIV(*value);
                              printf("  Hello, %d %s!\n", el_int, key);
                           } else {
                              printf("  (ignored) %s\n", key);
                           }
                     }
                 }

Here we first have to get the keys from our additional C<AV>
argument. We loop over them, get they actual key with C<av_fetch>,
check whether that key is really a string with C<SvPOK> and then get
the respective value from the hash with C<hv_fetch>. From there we
need to check for the type of the value and handle it with the
according printf.

=head3 Intermediate summary

We now know how to get and return scalar options, and can handle
scalars when they are single values or array/hash references.

That's it for day 2.
